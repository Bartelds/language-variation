<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html40/loose.dtd">
<html>
<head>
  <title>RuG/L04 - Manuals - features</title>
  <link rel="stylesheet" type="text/css" href="manuals.css">
</head>
<body>

<center>
<H1><a href="http://www.let.rug.nl/~kleiweg/L04/"><img src="RuG-L04.gif" alt="RuG/L04" border="0"></a></H1>
<h2>Manuals</h2>
<h3>features</h3>
</center>

<div class="warn">
2010/07/23<br>
WARNING: There was a serious bug in this program prior to version 2.00
<p>
This bug was in the way pre-modifiers were handled. Instead of applying
	a pre-modifier to just the first following head, it was applied
	to all the remaining heads in the same word as well.
<p>
This means that if you have used pre-modifiers, your results were wrong.
Sorry.
</div>

<h4>Description</h4>

<div class="text">
feature difference calculation for Levenshtein measurement
</div>

<h4>Synopsis</h4>

<div class="text">
<b>features</b> [<b>-a</b>] [<b>-c</b>] [<b>-C</b>&nbsp;<em>int</em>]
      [<b>-d</b>|<b>-o</b>|<b>-x</b>] [<b>-g</b>] [<b>-l</b>] [<b>-T</b>]
[<b>-e</b>&nbsp;<em>filename</em>] [<b>-f</b>&nbsp;<em>filename</em>] [<b>-t</b>&nbsp;<em>filename</em>]
 <em>configfile</em> <em>datafile(s)</em>
</div>

<h4>Options</h4>

<div class="text">
<dl>
<dt><b>-a</b>
<dd>Use ANSI escape sequences for error messages
<dt><b>-c</b>
<dd>Continue on data error
<dt><b>-C</b> <em>int</em>
<dd>Continue on data error, stop after this many errors
<dt><b>-d</b>
<dd>Decimal codes in token list (option -t) and error messages
<dt><b>-e</b> <em>filename</em>
<dd>Save to file: error log
<dt><b>-f</b> <em>filename</em>
<dd>Save to file: list of all feature sets
<dt><b>-g</b>
<dd>Don't map reals to integers
<dt><b>-l</b>
<dd>Show labels in error messages
<dt><b>-o</b>
<dd>Octal codes in token list (option -t) and error messages
<dt><b>-t</b> <em>filename</em>
<dd>Save tokenized files
<dt><b>-T</b>
<dd>Save to file: list of all token strings
<dt><b>-x</b>
<dd>Hexadecimal codes in token list (option -t) and error messages
</dl>
</div>

<h4>Purpose</h4>

<div class="text">
This program is a preprocessor to the <a href="leven.html">leven</a> program.
It translates dialect <a href="leven.html#dat">datafiles</a> from one form into another.
<p>
Sequences of tokens in the data that represent
one sound are combined into a set of feature values. Each unique set of
feature values is replaced with a unique number. These values are written to
the output files, which have the name of the input files with the
extension <b><tt>.ftr</tt></b> appended.
<p>
In addition, the differences between all sets of feature values are calculated,
and saved to the file <b><tt>features.table.out</tt></b>, which can be used by the
<a href="leven.html">leven</a> program.
<p>
A typical usage is:
<p>
<pre class="code">
    features configfile data/*.txt
    leven -s features.table.out  <i>(other options)</i>  data/*.txt.ftr
</pre>
<p>
The input <a href="leven.html#dat">datafiles</a> should be in the same format
as used by the <a href="leven.html">leven</a> program, accept that all
data must be in the form of ascii strings preceded by a minus sign. Data in the form
of sequences of numeral preceded by a plus sign are not allowed.
<p>
The new files will have data in numeral format.
<p>
As an example, part of an the input datafile could have these lines:
<pre>
    : Aachen
    - "t7n@stI_-S
</pre>
In the output file, those lines could be translated to something like:
<pre>
    : Aachen
    + 17 116 19 3 27 17 77 14
</pre>

</div>

<h4>See also</h4>

<div class="text">
<a href="features-grammar.txt">grammar</a>: concise description of the
      configuration file format.
<p>
<a href="features-example.txt">example</a>: an example of a configuration file.
<p>
<a href="xstokens.html">xstokens</a>: a simpler but less accurate alternative to
the <b><tt>features</tt></b> program.
</div>

<h4>The format of the configuration file</h4>

<div class="text">
Symbols (keywords, numbers, etc.) are separated by spaces and/or tabs. Empty
lines are ignored. The hash symbol (<b><tt>#</tt></b>) is the start of a
comment that continues to the end of the line. However, it is possible to
define an input string that starts with a hash. Spaces in input strings
have to be coded in the configuration file as <b><tt>[[SP]]</tt></b>.
The configuration file is case sensitive.
<p>
The configuration file has five parts, in a fixed order. All parts must be
present, even if one is empty. The five parts start with a key word:
<pre>
    DEFINES

    FEATURES

    TEMPLATES

    INDELS

    TOKENS
</pre>
</div>

<h4>Configuration file, part 1: DEFINES</h4>

<div class="text">
In this part, some variables can be set.
<p>
<b>VERSION</b>
<p>
Examples:
<pre>
    VERSION 0       # you shouldn't use this

    VERSION 1

    VERSION 2
</pre>
The program <b><tt>features</tt></b> version 1.00 fixes a methodological error
      of earlier versions.
      The program will run as before with old configuration files, or if you
      set VERSION&nbsp;0. To use the fix, you need to set VERSION&nbsp;1 or&nbsp;2, and make some
      further changes in older configuration files in the part&nbsp;2: FEATURES.
<p>
<b>TOP</b>
<p>
Examples:
<pre>
    TOP 255

    TOP 65535       # this is the default
</pre>
The Levenshtein program <b><tt>leven</tt></b> reads differences as integer values. These are
in the range from 0 to 65535. When the table of differences is very
large, it may be necessary to use the alternative compiled program
<b><tt>leven-s</tt></b>, which used differences in the range from 0 to 255, and
      uses less memory.
<p>
The alternative compiled program <b><tt>leven-r</tt></b> uses differences as
	real values (and uses even more memory, and makes the program
	slower).

<p>
The program <b><tt>features</tt></b> maps the calculated differences between
feature value sets onto the range from 0 to the value of <b><tt>TOP</tt></b>,
unless you specify the option <b><tt>-g</tt></b> on the command line, in which case the result can
	be used with <b><tt>leven-r</tt></b>.
<p>
<b>SUBSTMAX</b>
<p>
Examples:
<pre>
    SUBSTMAX 1.0    # this is the default

    SUBSTMAX 20
</pre>
This value has two purposes:
<ol>
<li>All distances between feature values sets are limited to the range from 0
  to the value of <b><tt>SUBSTMAX</tt></b>.
<li>VERSION 0 only: If two feature value sets have no features in common (each feature has no
  value in at least one feature set), than the difference between those
  two sets is set to the value of <b><tt>SUBSTMAX</tt></b>.
</ol>
<p>
<b>INDEL</b>
<p>
Examples:
<pre>
    INDEL 0.5

    INDEL 10
</pre>
This is the value of an <i>indel</i>, if it is not specified in another
manner. The default is the value of <b><tt>SUBSTMAX</tt></b> divided by two.
<p>
<b>METHOD</b>
<p>
Examples:
<pre>
    METHOD SUM            # equal to METHOD MINKOWSKI 1  (this is the default)

    METHOD SQUARE

    METHOD EUCLID         # equal to METHOD MINKOWSKI 2

    METHOD MINKOWSKI 1.4
</pre>
This determines how, from the differences between individual features, the difference
between two sets of features is calculated.
<p>
<b>TOKENSTRING</b>
<p>
Examples:
<pre>
    TOKENSTRING RAW   # this is the default

    TOKENSTRING ESC
</pre>
<p>
With <tt>TOKENSTRING ESC</tt>, tokens can be defined in the configuration file using
escape sequences. See <a href="#escape">below</a>.
<p>
<b>START</b>
<p>
Examples:
<pre>
    START 0   # this is the default

    START 1
</pre>
<p>
This defines the start condition of the mini-parser. See <a href="#miniparser">below</a>.

<p>
<b>RANGE</b>
<p>
Example:
<pre>
    RANGE 1 50 1
    RANGE 50 10000 2.1
</pre>
<p>
You can use RANGE zero, one or more times.
<p>
This defines a final mapping from
calculated value to output value. If a value falls in the range
of the first two values (inclusive), then it is replaced by the
third value.
<p>
If a calculated value falls inside one of these ranges, SUBSTMAX is ignored.
</div>

<h4>Configuration file, part 2: FEATURES</h4>

<div class="text">
In this part, all features are defined.
<p>
There are three types of features, indicated by a letter B, N, or D:
<p>
<dl>
<dt><b>B</b>
  <dd>bitmap (integer)
<dt><b>N</b>
  <dd>numeric (float)
<dt><b>D</b>
  <dd>discrete (integer)
</dl>
<p>
If you have two sets of feature values, <i>a</i> and <i>b</i>, and a
feature <i>i</i>, the difference between <i>a</i><sub>i</sub> and <i>b</i><sub>i</sub>
is:
<p>
<pre>
    B :    ( a[i] & b[i] ) ? 0.0 : 1.0
    N :    fabs( a[i] - b[i] )
    D :    ( a[i] == b[i] ) ? 0.0 : 1.0
</pre>
<p>
(the following...
<pre>
    A ? B : C
</pre>
...is C-code shorthand for:
<pre>
    if A does NOT return 0
      then do B
      else do C
</pre>
)
<p>
In prose, for bitmaps: if <i>a</i><sub>i</sub> and <i>b</i><sub>i</sub> have at
least one bit in common set to 1 in both bitmaps, then the difference is
0. It is 1 otherwise. The difference
between numeric features is the absolute difference between the two values.
The difference between two discrete features is 0 if they are equal, and 1 otherwise.
<p>
The above values are multiplied with the weight of the feature. So you get:
<pre>
    B :    ( a[i] & b[i] ) ? 0.0 : w
    N :    fabs( a[i] - b[i] ) * w
    D :    ( a[i] == b[i] ) ? 0.0 : w
</pre>
The weight of each feature is defined with the definition of the feature
      itself. The default weight is 1.
<p>
Here are some examples of feature definitions for VERSION&nbsp;1 and&nbsp;2 (see part DEFINES above):
<pre>
    N 2 v_advancement   # numeric feature, with default difference 2.0, weight 1.0
    N 1 v_high          # three more numeric features, with default difference and weight 1.0
    N 1 v_long
    N 1 v_rounded

    D 1 .7 breathy      # a discrete feature, with default difference 1.0 and weight 0.7

    B 1 3 type          # a bitmap feature, with default difference 1.0 and weight 3.0
</pre>
<p>
Differences between versions (set in part DEFINES above):
<p>
In VERSION&nbsp;0, the first value in the lines above is missing. There can be at
most one value between the first letter and the label. If there is a
value, it will set the weight. In VERSION&nbsp;0, if the difference between
two feature sets needs to be calculated, and if the feature is undefined in
one or both features sets, the difference is set to 0. That is probably
not what you want, so you should VERSION&nbsp;1 or&nbsp;2 instead.
<p>
In VERSION&nbsp;1, the first value is the feature's default difference, to be used
if two feature sets are compared and one or both has this feature undefined.
The default difference gets multiplies by the weight.
<p>
In VERSION&nbsp;2, the default difference is used only if the feature is
	defined in one feature set, but not in the other. If the feature is
	undefined in both feature sets, the difference is set to 0.
<p>
There are three predefined features:
<pre>
    N 1 WEIGHT
    N 1 INDEL
    B 1 STATE
</pre>
These features have a special meaning, explained below. They are not used to
calculate the differences between feature value sets in the normal way.
However, they can be handled (assigned to and modified) like normal features.
</div>

<h4>Configuration file, part 3: TEMPLATES</h4>

<div class="text">
You can use templates so you don't have to write out the complete list of feature assignments
for each input token. These templates help a great deal in keeping things well organised.
<p>
Examples:
<pre>
    T vowel                # start of template 'vowel'
    F v_long = 1           # assign value 1 to feature 'v_long'
    F v_rounded = -.5

    T v_close              # start of template 'v_close'
    F v_high = 1.5
</pre>
<p>
In this part of the configuration file, the letter T is used for the definition
of a template. Here, the letter T can be used to start a single template only.
<p>
In the parts of the configuration file that follow, the letter T
is used to execute a template, and it can be used with multiple templates
at once.
</div>

<h4>Configuration file, part 4: INDELS</h4>

<div class="text">
If there are feature assignments in this part of the configuration file, the
      resulting set of feature values is used to compare to other sets of
      feature values when they are used as indels. In this case, the value
      assigned to the variable <b><tt>INDEL</tt></b> in the first part of the configuration
      file is ignored.
<p>
Example:
<pre>
    T consonant c_glottal c_fricative   # like the consonant h
    T vowel v_mid v_central             # like the vowel schwa
    F v_rounded = 0                     # between a rounded and unrounded vowel
</pre>
</div>

<h4>Configuration file, part 5: TOKENS</h4>

<div class="text">
This part defines tokens, substrings from the input datafiles, and the effect
they have on feature values. Each token consists of one or more letters.
A string is parsed from left to right, searching for a substring that
matches one defined here. If multiple substrings match, the longest is used.
<p>
Tokens come in three flavours, indicated with the letters H, M or P:
<p>
<dl>
<dt><b>H</b>
  <dd>head
<dt><b>M</b>
  <dd>modifier
<dt><b>P</b>
  <dd>pre-modifier
</dl>
<p>
End there is one special token:
<p>
<dl>
<dt><b>EOT</b>
  <dd>for the empty token an the end of a string, only useful in
  combination with the mini parser (see below)
</dl>
<p>
One sound, one segment that is to be translated into a single set of feature values,
consists of one or more tokens:
<p>
<ol>
<li>0, 1 or multiple pre-modifiers
<li>head
<li>0, 1 or multiple modifiers
</ol>
<p>
Each token can change feature values. Usually, the head assigns initial values
to features, while modifiers change those values.
<p>
If the input consists of two pre-modifiers (P1, P2), a head (H), and two
modifiers (M1, M2), like this:
<pre>
    P1 P2 H M1 M2
</pre>
... then the feature value changes are processed in this order:
<pre>
    H M1 M2 P2 P1
</pre>
<p>
So, the actions for the head are processed first, then the modifiers, and
lastly, the pre-modifiers in reverse order.
<p>
Each token is defined in the configuration file with a letter indicating the
type, followed by calls to templates (T) or other feature value changes
(F). Examples:
<p>
<pre>
    H y
    T vowel v_close v_front v_rounded

    H @
    T vowel v_mid v_central
    F v_rounded = 0

    # the END OF TEXT token has no substring and sets no features:
    EOT
</pre>
<p>
Examples of actions that can be performed on feature values:
<pre>
    # Features of type bitmap, B
    F featB = 4     # assign the value 4 (integer)
    F featB - 3     # clear the bits from the value 3: new = old XOR (old AND 3)
    F featB + 3     # set the bits from the value:     new = old OR 3
    F featB ! 3     # flip the bits from the value 3:  new = old XOR 3
    F featB U       # make the bitmap undefined

    # Features of type numeral, N
    F featN = 4     # assign the value 4 (float)
    F featN - 3     # decrease with 3
    F featN + 3     # increase with 3
    F featN * 3     # multiply by 3
    F featN U       # make it undefined

    # features of type discrete, D
    F featD = 4     # assign the value 4 (integer)
    F featD U       # make it undefined
</pre>
<p>
Note that, usually, you don't need to un-define a feature value. All feature
values are undefined until a value is assigned. Also note that you can't modify
a feature before you have assigned to it. (The features <b><tt>WEIGHT</tt></b>
and <b><tt>STATE</tt></b> are the exceptions. WEIGHT is set to 1 as soon as a
head is recognised. STATE is set to 0 at the start of each string, and
changes are persistent until the end of the string.)
<p>
<a name="escape"></a>
<b>Escape sequences</b>
<p>
If <tt>TOKENSTRING ESC</tt> is set in the <tt>DEFINES</tt> part of the
configuration file, then you can use escape sequences to define token strings.
This is useful if the data is not in a standard character set. Escape sequences
	are:
<ul>
<li><tt>\d&nbsp;&nbsp;</tt> followed by three decimal digits
<li><tt>\&nbsp;&nbsp;&nbsp;</tt> followed by three octal digits
<li><tt>\x&nbsp;&nbsp;</tt> followed by two hexadecimal digits
<li><tt>\\</tt>
</ul>
The last represents a single backslash.
<p>
With <tt>TOKENSTRING ESC</tt>, these are equivalent:
<p>
<pre>
    H A\\+
    H \d065\d092\d043
    H \101\134\053
    H \x41\x5C\x2B
</pre>
<p>
With <tt>TOKENSTRING RAW</tt>, the same token can only be defined as:
<p>
<pre>
    H A\+
</pre>
<p>
<b>Ignoring tokens</b>
<p>
When tokens are defined with a letter <b><tt>I</tt></b> appended to the first
letter, then no actions on features are performed. Examples:
<p>
<pre>
    HI x
    MI _y
    PI ^
</pre>
<p>
In case of a token of type head: the complete sound is ignored. There will be
no token in the output sequence. Pre-modifiers and modifiers with this head
will also be ignored. If STATE was already changed by a pre-modifier, that
change will remain in effect.
<p>
In case of a token of type modifier or pre-modifier: no feature changes are
made, including STATE.
<p>
<b>Indel</b>
<p>
If a values is assigned to the pseudo-feature <B><tt>INDEL</tt></b>, that will
be the value of an indel for the current sound, ignoring what was defined in the
main parts DEFINES and INDELS of the configuration file.
</div>

<a name="miniparser"></a>
<h4>Configuration file: Mini parser</h4>

<div class="text">
It is possible to pose conditions on the processing of input. This is done by
putting a number and an operator before a definition. Conditions can be used:
<ul>
<li>in the part <b><tt>TEMPLATES</tt></b> in front of actions on features
<li>in the part <b><tt>TOKENS</tt></b>, in front of the token itself, in front
  of calls to templates, and in front of actions on features
</ul>
Examples:
<pre>
    H a

    :  7   H a
</pre>
The first is the ordinary definition. the second is the conditional definition.
The token is recognised only if the 'state', interpreted as a bitmap,
has at least one bit in the number 7 set (7 = 1 + 2 + 4, or binary: 001 +
010 + 100). It matches if the "bitwise and" is not zero.
<p>
When two token definitions of equal length match the input, one token defined with a
conditional, the other without, the definition with conditional is used if
the condition also matches, and the other definition is used if the condition doesn't match.
<p>
If two tokens definition of equal length match, both with conditions, and both conditions
match also, it is undetermined which of the two definition is used.
<p>
If a definition for a token has a condition on the token itself, and the
condition doesn't match, the rule isn't used, and none of the actions on
feature values are executed. But you can also use conditions on
actions or the call to templates, so the token can match the input and
only part of the actions executed. For example:
<p>
<pre>
    ^: 3   F featA + 4
</pre>
The value of feature <tt>FeatA</tt> is increased only if the 'state',
interpreted as a bitmap, has no positive match with the number 3. It
matches if "bitwise and" is zero.
<p>
<pre>
     = 0   F featB = 1
</pre>
The values of feature <tt>FeatB</tt> is set to 1 if the state is exactly 0.
<p>
<pre>
    ^= 9   T template1 template2
</pre>
Both template <tt>template1</tt> and <tt>template2</tt> are executed if the
state does not match the value 9 exactly.
<p>
The state is an integer value. It can be changed by changing the value of the
pre-defined 'pseudo-feature' <b><tt>STATE</tt></b>. For example:
<pre>
    F STATE + 2    # set the non-zero bits from value 2 (new STATE = old STATE OR 2)
</pre>
<p>
NOTE: Before the processing of each token, the state is saved. That state is
used for all tests done for that token, both the token match itself, as well as
the execution of templates or other changes of feature values. Changing
the value of the feature STATE will have no effect until the next token
is processed.
<p>
NOTE: Usually, actions for pre-modifiers are executed last, when the actions
for head and modifiers have finished. However, changes to STATE have effect as soon
as pre-modifiers are parsed. However (again), changes to other features are
made under condition of the state at the time of parsing the corresponding token.
<p>
Schematicly, with two pre-modifiers (P1, P2), head (H), and two modifiers (M1, M2):
<p>
<pre>
    STATE1 = current STATE
    parse P1 : - change STATE if requested
    STATE2 = current STATE
    parse P2 : - change STATE if requested
    STATE3 = current STATE
    parse H  : - change features on condition of state STATE3
               - change STATE if requested
    STATE4 = current STATE
    parse M1 : - change features on condition of state STATE4
               - change STATE if requested
    STATE5 = current STATE
    parse M2 : - change features on condition of state STATE5
               - change STATE if requested
      - change features on condition of state STATE2 for P2
      - change features on condition of state STATE1 for P1
</pre>
<p>
At the start of each string, (sequence of tokens making one dialect item), STATE
is set to the value of START as defined in the DEFINES section of the configuration
file, or to 0 if START is not set.
<p>
For determining the feature set of an <i>indel</i> (part INDELS of the
configuration file), STATE is set to 0.
<p>

<b>Mini parser and EOT</b>
<p>

Using EOT with a STATE condition enables you to check that the mini
parser is in the right state at the end of the input string. Example:
<p>
<pre>
    : 1 EOT

    ^: 4 EOT
</pre>
<p>
It is OK if at the end of the input string, the mini parser matches
state 1, or doesn't match state 4. Any other state causes an error.
<p>
If you don't use EOT, any state at the end of the strings is acceptable.
	This is identical to using EOT without a condition. This is
	unnecessary:
<p>
<pre>
    EOT
</pre>
<p>
All (pre-)modifiers in combination with EOT are ignored.



<p>
<b>Mini parser, an example</b>
<p>
Stress is usually marked at the start of a syllable. It would make sense to
have a feature 'stress' on a vowel. But there may be one or more consonants
between the stress marker and the first vowel of the syllable. So the stress
must be remembered until it can be translated into a feature. This is how this
can work:
<p>
<pre>
    TEMPLATES

    T vowel
    F stress = 0         # no stress
    : 1 F stress = 1.0   # primary stress
    : 2 F stress = 0.5   # secondary stress
    F STATE - 3          # clear stress bits



    TOKENS

    P "           # primary stress
    F STATE + 1

    P %           # secondary stress
    F STATE + 2


    : 4 EOT       # end of string is accepted when state matches 4

</pre>
</div>

<h4>Configuration file: Weights</h4>

<div class="text">
There is a pseudo-feature <b><tt>WEIGHT</tt></b>, with default value 1. How is this used?
An example:
<p>
Suppose you have three features, <i>x</i>, <i>y</i>, and <i>z</i>, with feature
weights <i>wx</i>, <i>wy</i>, and <i>wz</i>, and you have two sets of
feature values, <i>A</i> and <i>B</i>. In addition, both sets of
feature values have a pseudo-feature WEIGHT. Suppose that in the part DEFINES
of the configuration file, you have set METHOD SUM. The function
<i>d()</i> determines the simple difference between two features, based
on type of feature (bitmap, numeric, discrete). The difference <i>F</i> between
sets <i>A</i> and <i>B</i> is now determined as follows:
<p>
<pre>
    F = ( d(A[x], B[b]) * wx +
          d(A[y], B[y]) * wy +
          d(A[z], B[z]) * wz   )

    F = F * A[WEIGHT] * B[WEIGHT]

    if (F &lt; 0)
        F = 0

    if (F &gt; SUBSTMAX)
        F = SUBSTMAX
</pre>
<p>
If you have used METHOD SQUARE, you get:
<p>
<pre>
    F = ( (d(A[x], B[b]) * wx) ^ 2 +
          (d(A[y], B[y]) * wy) ^ 2 +
          (d(A[z], B[z]) * wz) ^ 2   )

    F = F * A[WEIGHT] * B[WEIGHT]

    if (F &lt; 0)
        F = 0

    if (F &gt; SUBSTMAX)
        F = SUBSTMAX
</pre>
<p>
And with METHOD EUCLID, you get:
<p>
<pre>
    F = ( (d(A[x], B[b]) * wx) ^ 2 +
          (d(A[y], B[y]) * wy) ^ 2 +
          (d(A[z], B[z]) * wz) ^ 2   )

    F = sqrt(F) * A[WEIGHT] * B[WEIGHT]

    if (F &lt; 0)
        F = 0

    if (F &gt; SUBSTMAX)
        F = SUBSTMAX
</pre>
<p>
And with METHOD MINKOWSKI, with value <i>rho</i>, you get:
<p>
<pre>
    F = ( (d(A[x], B[b]) * wx) ^ rho +
          (d(A[y], B[y]) * wy) ^ rho +
          (d(A[z], B[z]) * wz) ^ rho   )

    F = F^(1/rho) * A[WEIGHT] * B[WEIGHT]

    if (F &lt; 0)
        F = 0

    if (F &gt; SUBSTMAX)
        F = SUBSTMAX
</pre>
</div>


</BODY>
</HTML>
