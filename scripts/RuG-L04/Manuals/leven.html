<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html40/loose.dtd">
<html>
<head>
  <title>RuG/L04 - Manuals - leven</title>
  <link rel="stylesheet" type="text/css" href="manuals.css">
</head>
<body>
<script><!--
if(!top.PeterCJKleiwegIndex)
    document.writeln('<small><a target="_top" href="http://www.let.rug.nl/~kleiweg/">Home<\/a><\/small><br><hr>');
// --></script>

<center>
<H1><a href="../"><img src="RuG-L04.gif" alt="RuG/L04" border="0"></a></H1>
<h2>Manuals</h2>
<h3>leven</h3>
</center>

<h4>Description</h4>

<div class="text">
using the Levenshtein algorithm, derive a difference matrix for a set of
locations based on sets of strings for each location
</div>

<h4>Warning</h4>

<div class="text">
Older versions of this program had a bug in the calculation of <a href="#c">Cronbach Alpha</a>.
See <a href="bugtest.html">bugtest</a> for details.
</div>

<h4>Synopsis</h4>

<div class="text">
<b>leven</b> <b>-n</b> <em>number</em>
	    [<b>-d</b>&nbsp;<em>filename</em> |
	    [<b>-i</b>&nbsp;<em>filename</em> |
	    <b>-s</b>&nbsp;<em>filename</em> |
            <b>-g</b> ]
	    [<b>-l</b>&nbsp;<em>filename</em>]
            [<b>-L</b>]
	    [<b>-o</b>&nbsp;<em>filename</em>]
	    [<b>-p</b>&nbsp;<em>filename</em>]
            [<b>-b</b>&nbsp;<em>percentage</em>]
            [<b>-B</b>]
            [<b>-c</b> [<b>-x</b>]]
            [<b>-e</b>]
            [<b>-h</b>] [<b>-r</b>] [<b>-R</b>&nbsp;<em>float</em>]
            [<b>-f</b>&nbsp;<em>number</em>]
            [<b>-F</b>]
            [<b>-m</b>]
            [<b>-N</b>&nbsp;<em>number</em>]
            [<b>-q</b> | <b>-Q</b>]
            [<b>-t</b>]
            [<b>-S</b>&nbsp;<em>filename</em>]
            [<b>-a</b>&nbsp;<em>float</em>]
            [<b>-v</b>&nbsp;<em>float</em>]
            [<b>-z</b>&nbsp;<em>float</em>]
	    <em><a href="#dat">datafile(s)</a></em>
<p>
<b>leven</b> <b>-P</b> <b>-n</b> <em>number</em>
            [<b>-C</b>&nbsp;<em>number</em>]
	    [<b>-i</b>&nbsp;<em>filename</em> |
	    <b>-s</b>&nbsp;<em>filename</em> ]
	    [<b>-o</b>&nbsp;<em>filename</em>]
            [<b>-B</b>]
            [<b>-e</b>]
            [<b>-h</b>] [<b>-r</b>] [<b>-R</b>&nbsp;<em>float</em>]
            [<b>-N</b>&nbsp;<em>number</em>]
            [<b>-q</b> | <b>-Q</b>]
            [<b>-S</b>&nbsp;<em>filename</em>]
            [<b>-a</b>&nbsp;<em>float</em>]
            [<b>-v</b>&nbsp;<em>float</em>]
            [<b>-z</b>&nbsp;<em>float</em>]
	    <em><a href="#P">datafile</a></em>
</div>

<h4>Options</h4>

<div class="text">
<dl>

<dt><b>-a</b> <em>float</em>
<dd><a href="#wl">weight learning</a>: parameter alpha

<dt><b>-b</b> <em>percentage</em>
<dd>do bootstrapping with given percentage (usually: 100)

<dt><b>-B</b>
<dd><a href="#B">binary comparison instead of Levensthein</a>

<dt><b>-c</b>
<dd><a href="#c">Cronbach Alpha</a>

<dt><b>-C</b>
<dd><a href="#P">select column</a> (this option can be used more than once)

<dt><b>-d</b>  <em>filename</em>
<dd><a href="#o">output file for standard deviation</a>

<dt><b>-e</b>
<dd><a href="#e">equal weight for indel and subst</a>


<dt><b>-f</b>  <em>int</em>
<dd><a href="#f">minimum number of occurrences required for each variant</a>
<dt><b>-F</b>
<dd><a href="#F">skip files with less than two variants, depends on option -f</a>

<dt><b>-g</b>
<dd><a href="#cGIW">character-based G.I.W.</a>

<dt><b>-h</b>
<dd><a href="#h">Hamming distance instead of Levensthein</a>

<dt><b>-i</b>  <em>filename</em>
<dd><a href="#i">file with indel values</a>
<dt><b>-l</b>  <em>filename</em>
<dd><a href="#l">file with location labels</a>
<dt><b>-L</b>
<dd>skip locations that are not listed in the file with location labels
<dt><b>-m</b>
<dd><a href="#o">calculate median difference instead of mean difference</a>
<dt><b>-n</b>  <em>int</em>
<dd><a href="#n">number of locations</a>

<dt><b>-N</b>  <em>int</em>
<dd><a href="#normalise">select another normalisation function</a>

<dt><b>-o</b>  <em>filename</em>
<dd><a href="#o">output file</a>
<dt><b>-p</b>  <em>filename</em>
<dd><a href="#p">file defining a linkage partition</a>

<dt><b>-P</b>
<dd><a href="#P">do pairwise calculations</a>

<dt><b>-r</b>
<dd><a href="#r">numeric distance instead of Levensthein</a>

<dt><b>-R</b>
<dd><a href="#r">with -r: Minkowski value (default: 2)</a>

<dt><b>-s</b>  <em>filename</em>
<dd><a href="#s">file with substitution and indel values</a>
<dt><b>-q</b>
<dd>quiet
<dt><b>-Q</b>
<dd>a bit quiet (no listing of input files)
<dt><b>-t</b>
<dd><a href="#t">test all input files</a>

<dt><b>-S</b> <em>filename</em>
<dd><a href="#wl">weight learning</a>: output file with updated substitution and indel values

<dt><b>-v</b> <em>float</em>
<dd><a href="#wl">weight learning</a>: with -u, increment for all alignments

<dt><b>-x</b>
<dd><a href="#c">also give Cronbach's Alpha using old (incorrect) formula</a>

<dt><b>-z</b> <em>float</em>
<dd><a href="#wl">weight learning</a>: with -u, exponent in PMI formula

</dl>
</div>

<a name="t"></a>
<h4>Testing</h4>

<div class="text">
Before doing any time-consuming calculations, it is recommended to run
the program in test mode, using option <b>-t</b>, to check if all input files are syntactically
correct.
</div>

<h4>Cancelling</h4>
<div class="text">
The program will abort if a file _CANCEL_.L04 exists in the current directory,
or if it is created while the program is running. This is useful for stopping
long running calculations from a GUI, such as <a href="../pyL04/">pyL04</a>.
</div>

<a name="n"></a>
<h4>Number of locations</h4>

<div class="text">
The total number of locations used in the datafiles must be specified
with the option <b>-n</b>. This number must be identical to the highest
index number in the <a href="#l">location file</a>, if used.
</div>

<h4>Weights for <em>indels</em> and <em>substitutions</em></h4>

<div class="text">
By default, all indels have the weight 1, and all substitutions have weight 2. There are two ways to alter this behaviour:
<p>
<b><a name="i">Specifying weights for <em>indels</em> only</a></b>
<p>
Use the option <b>-i</b> to specify a file that lists the indel weights.
Substitution weights are calculated by adding the indel
weights for each pair of character codes.
<p>
The indel file should be written as follows:
<pre>
    PRINT "F:"   # That is, a string starting with <b>F:</b> without quotes
    NEWLINE      # This line should only be present if the file
                 #     is to be used with <b>leven-r</b>
    PRINT max
    NEWLINE
    FOR i = 1 TO max
        PRINT w[i]
        NEWLINE
</pre>
<tt>max</tt> is the highest character code number used in the dialect
data.
<p>
<tt>w[i]</tt> is the weight for inserting or deleting a character with
code <em>i</em>.
<p>
Note: There are three alternative versions of the program:
<b><tt>leven</tt></b>, <b><tt>leven-r</tt></b>, and <b><tt>leven-s</tt></b>.
For <b><tt>leven</tt></b>, all weights should be integers in the range 0
	through 65535.
For <b><tt>leven-s</tt></b> (compiled with <tt>LEVEN_SMALL</tt> defined), all weights should be integers in the range 0
	through 255.
For <b><tt>leven-r</tt></b> (compiled with <tt>LEVEN_REAL</tt> defined), all
	weights should be reals, in the range from 0 to <tt>MAX_FLT</tt> (a platform
	dependent limit).
<p>
<b><a name="s">Specifying weights for <i>indels</i> and <i>substitutions</i></a></b>
<p>
Use the option <b>-s</b> to specify a file that lists both indel weights
and substitution weights.
<p>
The substitution file should be written as follows:
<pre>
    PRINT "F:"   # That is, a string starting with <b>F:</b> without quotes
    NEWLINE      # This line should only be present if the file
                 #     is to be used with <b>leven-r</b>
    PRINT max
    NEWLINE
    FOR i = 1 TO max
         FOR j = 0 TO i - 1
             PRINT w[i,j]
             NEWLINE
</pre>
<tt>max</tt> is the highest character code number used in the dialect
data.
<p>
<tt>w[i,j]</tt>, for <em>j &gt; 0</em>, is the weight for
substituting a character with code <em>i</em> for a character with code
<em>j</em>, or vice versa.
<p>
<tt>w[i,0]</tt> is the weight for inserting or deleting a character with
code <em>i</em>.
<p>
Note: There are three alternative versions of the program:
<b><tt>leven</tt></b>, <b><tt>leven-r</tt></b>, and <b><tt>leven-s</tt></b>.
For <b><tt>leven</tt></b>, all weights should be integers in the range 0
	through 65535.
For <b><tt>leven-s</tt></b> (compiled with <tt>LEVEN_SMALL</tt> defined), all weights should be integers in the range 0
	through 255.
For <b><tt>leven-r</tt></b> (compiled with <tt>LEVEN_REAL</tt> defined), all
	weights should be reals, in the range from 0 to <tt>MAX_FLT</tt> (a platform
	dependent limit).
</div>

<a name="l"></a>
<h4>Specifying labels for locations</h4>

<div class="text">
Use the option <b>-l</b> to specify a <a href="formats.html#lbl">file with
labels for locations</a>. If this
option is absent, numbers are used in the output file instead. You can't
use labels in the data files if you omit this option.
</div>

<a name="dat"></a>
<h4>Datafiles</h4>

<div class="text">
Each additional datafile should hold dialect data, one file for each
dialect item. All words in a single file are compared for each pair of locations.
<p>
A weight can be specified to a datafile (default 1), preceded by an
asterisk. This can be used to alter the relative importance of one
datafile compared to another. Only the last weight specified in a
particular file will be used, and it will be used for all of that
datafile, even for those strings preceding the weight specification.
<p>
Each location is introduced with a location number (counting from 1
upward) or a colon followed by a location label.
<p>
Words can be specified in two ways, with a leading minus as an ascii
string, or with a leading plus as a sequence of decimal numbers.
<p>
Example:
<pre>
    * 1.2
    5
    - fiets
    - fIts
    + 102 116 115
    : GR7
    - fietse
    - fiets
    - fiets
    5
    - flits
</pre>
As you can see, each location can have more than one word. In this
example there are two locations: location number 5 (note that this
location is mentioned twice), which has four words, of which the third
is specified as a sequence of numbers; and the location with label <tt>GR7</tt>,
which has three words.
<p>
The order of the locations is immaterial. Not every location needs to be
present in each data file. In the end, the sum of all differences
between two locations is divided by the number of times that averaged
difference was calculated, taking any weights specified in the datafiles
into account.
<p>
The rest of this section is a bit technical. You can skip to the next
section, if you want.
<p>
For this file, the actual difference between location number 5 and
location <tt>GR7</tt> is calculated by choosing a (near-)optimal one-by-one
alignment of the strings of these locations. Optimal, meaning: the sum
of the pair-wise differences is minimised. The actual difference is the
average of these pair-wise differences.
If two locations have different
numbers of strings, all strings of one or both locations are duplicated
once or more, until the locations have the same number of strings. In
this case, the strings for location number 5 are duplicated three times,
and those of location <tt>GR7</tt> four times, resulting in twelve strings at
each location.
<p>
The rationale for this procedure is as follows. Look at this example:
<ul>
<li>suppose you have two location, <em>P</em> and <em>Q</em>
<li>suppose you have two variant strings of the word being tested, call
them <em>A</em> and
<em>B</em>
<li>suppose the Levenshtein difference between the two variants <em>A</em> and
<em>B</em> is 1
<li>suppose you have these variants at location <em>P</em>: <em>B,A,A</em>
<li>suppose you have these variants at location <em>Q</em>: <em>A,B,B,A,A,A</em>
</ul>
What would happen if you calculated the average difference of all
possible pairs? You would get:
<table>
<tr><td><td>Q:<td>A<td>B<td>B<td>A<td>A<td>A
<tr><td>P:
<tr><td>B<td><td>1<td>0<td>0<td>1<td>1<td>1
<tr><td>A<td><td>0<td>1<td>1<td>0<td>0<td>0
<tr><td>A<td><td>0<td>1<td>1<td>0<td>0<td>0
</table>
gives 8 / 18 = .444 between <em>P</em> and <em>Q</em> for this word. But if
you look at how the variant strings of this word are distributed among
<em>P</em> and <em>Q</em> you can see that they are in identical proportions. So the
difference should be zero. The (near-)optimal one-by-one alignment
gives you this value:
<table>
<tr><td align="right">P:<br>&nbsp;<br>Q:</td>
    <td align="center">B<br>|<br>B</td>
    <td align="center">A<br>|<br>A</td>
    <td align="center">A<br>|<br>A</td>
    <td align="center">B<br>|<br>B</td>
    <td align="center">A<br>|<br>A</td>
    <td align="center">A<br>|<br>A</td>
    <td>(variants repeated twice)<br>&nbsp;<br>
        (variants sorted to line up with first row)
<tr><td>differences:
    <td align="center">0</td>
    <td align="center">0</td>
    <td align="center">0</td>
    <td align="center">0</td>
    <td align="center">0</td>
    <td align="center">0</td>
</table>
gives 0 / 6 = 0.
<p>
Note that determining the optimal one-by-one alignment is a variant of the
<em>Travelling Salesman Problem</em>, which is computationally
expensive. A heuristic is used that gives you a reasonable approximation.
</div>

<h5>Unicode</h5>

<div class="text">
A datafile can contain the following line:
<pre>
    %utf8
</pre>
The remainder of this file will be interpreted as UTF-8 (data only,
labels are not effected). See <a href="unicode.html">Unicode</a>.
</div>

<a name="p"></a>
<h4>Defining a linkage partition</h4>

<div class="text">
If you are interested in only a small subset of the difference matrix,
you can use a linkage partition file. Such a file looks like this:
<pre>
    : 1 2
    : 2 3
</pre>
Lines not starting with a colon are ignored.
<p>
The numbers are location index numbers, numbered from 1 to <em>max</em>.
You can not use labels in this file.
In the example, the differences between locations 1 and 2, and between
locations 2 and 3 are calculated, but not between the locations with
numbers 1 and 3.
</div>

<a name="o"></a>
<h4>Output files</h4>

<div class="text">
By default,
results are written to the output file in the form of a
<a href="formats.html#dif">difference matrix</a>. If no <a href="#l">labels</a> are
available, numbers from 1 to <em>max</em> are used as labels, where
<em>max</em> is the number of locations.
<p>
The top of the output file contains comments that summarise the options used,
	and list some properties about the input data. Here is a short
	fragment:
<pre>
    #   Items  Locations  File
    #                     Variants: frequency(repeats)
    #     345      237    clearing_up.fon
    #                     268: 1(229) 2(24) 3(7) 4(2) 5(3) 6 7 11
</pre>
Explanation: the input file was <tt>clearing_up.fon</tt>. There were 345 items used,
      from 237 locations. There were 268 variant items in the input file. 229
      variants occurred only once, 24 variants occurred twice, seven items occurs three
      times, etc., a single variant occurred six times, another single variant
      occurred seven times, etc.
<p>
By default, the difference between two locations is the (weighted) mean of all
differences calculated between those two locations. If the option <b>-m</b> is
used, the difference between two locations is the <em>median</em> of the calculated differences.
Weights in the data files will be ignored. Note: this requires
<em>a&nbsp;lot</em> of memory.
<p>
If a <a href="#p">linkage partition</a> is used, differences are
written to file as a value followed by two index numbers, followed by --
if available -- two <a href="#l">location labels</a>.
Example:
<pre>
    .487308    2    1    Calcutta      Bombay
    .835438    3    2    "New Delhi"   Calcutta
</pre>
Note: the order used in the linkage partition file is lost.
<p>
If the option <b>-d</b> is used, then, for each pair of locations, the
<em>standard deviation</em> of the calculated differences between those two
locations will be returned in the output file specified by the option
<b>-d</b> in the form of a <a href="formats.html#dif">difference matrix</a>.
Weights in the data files will be ignored.
</div>

<a name="normalise"></a>
<h4>Normalisation</h4>

<div class="text">
At the top of the source code <b><tt>leven.c</tt></b> is a function
<tt>normalise()</tt>, which is currently defined as follows:
<pre>
    double normalise (double f, int len1, int len2, int minlen, int maxlen)
    {
        double
            result = 0;

        switch (normalise_function) {
            case 1:
                result = f / (len1 + len2);
                break;
            case 2:
                result = f / ((len1 > len2) ? len1 : len2);
                break;
            case 3:
                result = sqrt (f / (len1 + len2));
                break;
            case 4:
                result = f / minlen;
                break;
            case 5:
                result = f / maxlen;
                break;
            case 6:
                result = f;
                break;
            default:
                errit ("Normalisation function number %i undefined", normalise_function);
        }

        return result;
    }
</pre>
This function is called as soon as the Levenshtein algorithm has been applied
to two strings. The arguments to <tt>normalise()</tt> are the
value calculated by the Levenshtein algorithm, the lengths of both
strings, and the minimum and maximum length of the least-cost alignment(s).
(There may be several such alignments, of unequal length.)
<p>
The purpose of the function <tt>normalise()</tt> is to normalise the
Levenshtein distance. This is especially needed in cases where not all pairs
of strings are available for all pairs of locations, and the longer
strings that are available would skew the overall results, if
normalisation were omitted.
<p>
By default (case 1), the normalisation function normalises by dividing by the sum of
the lengths of the two strings. This makes sense, because in cases where
the two strings don't have any character in common, the Levenshtein
distance is proportional to the sum of the lengths of the two strings.
<p>
You might want to experiment with alternate normalisation
functions. You can select another predefined normalisation with the command line
option <b><tt>-N</tt></b> (case 2 ... case 5). Check the source code to see what types of
normalisation are available. You can easily add your own types of
normalisation (case 6, etc), and select these with the <b><tt>-N</tt></b> option.
If you do add to the definition of the function, make sure
you save and compile the source under a different file name.
</div>

<a name="c"></a>
<h4>Cronbach Alpha</h4>

<div class="text">
If you use the option <b><tt>-c</tt></b> Cronbach Alpha will be calculated. The
    result is printed on standard output and included as a comment at the top
    of the output file.
<p>
Using this option may require a lot of memory,
      depending on number and size of datafiles.
When the program runs out of memory, it will try to continue without
Cronbach Alpha.
<p>
It may be a good idea to limit the amount of memory available to the
program (for instance with <b><tt>ulimit&nbsp;-v</tt></b>). Because, if the
program starts using swap space on disk, it slows down to a crawl.
<p>
In versions older than version 1.80 of the <b>leven</b> program and
version 0.26 of the <b><a href="giw.html">giw</a></b> program, there was a
different formula used for calculating Cronbach Alpha. That
formula was incorrect. If you use option
<b><tt>-x</tt></b> in addition to option <b><tt>-c</tt></b>, you
get both old (imprecise) and new (correct) value, so you
can see how much 'damage' the old formula did.
</div>

<a name="e"></a>
<h4>Equal weight for indel and substitution</h4>

<div class="text">
Usually, with a plain Levenshtein comparison, the weight of an <em>indel</em> is
half the weight of a <em>substitution</em>. With the option
<b><tt>-e</tt></b> the weight of an <em>indel</em> is set equal to the weight
of a <em>substitution</em>.
</div>

<a name="cGIW"></a>
<h4>Character-based G.I.W.</h4>

<div class="text">
G.I.W. or <em>Gewichteter Identit&auml;tswert</em> is a measure to express
distance based on frequency of elements. If an element is rare,
the co-occurrence of that element in two places suggests a strong
correlation between those two places.
<p>
A word-based distance of G.I.W. can be calculated with the
<a href="giw.html">giw</a> program. That method is only suitable when
there are relatively few word variants in a dataset.
<p>
<em>Character-based G.I.W.</em> (cGIW) is a modification of the plain Levenshtein
	    distance. The costs of a substitution are listed below. (The cost
	of an indel is 0.5 in both cases, or 1 if the option <tt><a href="#e">-e</a></tt>
	was used.)
<p>
<table border="1" cellpadding="4">
<thead>
<tr><th><th>plain<th>cGIW
</thead>
<tbody>
<tr><td>equal
    <td>0
    <td>f / F
<tr><td>different
    <td>1
    <td>1
  </tr>
</tbody>
</table>
<p>
<dl>
<dt>f
<dd>The number of times the character in question is present, in the datafile being processed
<dt>F
<dd>The total count of all characters, in the datafile being processed
</dl>

</div>

<a name="B"></a>
<h4>Binary comparison</h4>

<div class="text">
If the option <b>-B</b> is used a binary comparison will be made, instead of a
Levenshtein distance calculation. If two
strings are not the same, the difference is set to 1 (or the weight of the
datafile, if specified).
</div>

<a name="h"></a>
<h4>Hamming disance</h4>

<div class="text">
If the option <b>-h</b> is used, the Hamming distance will be calculated, instead of the
Levenshtein distance. Strings in a single data file must be
      of the same length.
</div>

<a name="r"></a>
<h4>Numeric disance</h4>

<div class="text">
If the option <b>-r</b> is used, the numeric distance will be calculated, instead of the
Levenshtein distance.
For this measurement, a string is interpreted as a list of integer values,
using the ascii code of the characters.
Strings in a single data file must be of the same length.
<p>
The numeric distance between strings s1 and s2, with Minkowski value R is:
<blockquote>
( &Sigma; |s1<sub>i</sub> - s2<sub>i</sub>|<sup>R</sup> ) <sup>1/R</sup>
</blockquote>
The option <b>-R</b> determines the Minkowski value.
The default is 2 (Euclidean distance).
</div>

<a name="f"></a>
<h4>Minimum number of occurrences required for each variant</h4>

<div class="text">
The option <b>-f</b> can be used to set a minimum number each variant form
      should be present in the data before it is actually used. If you set this
      values to 2, each variant that occurs only once will be ignored. The
      rational behind this is that infrequent variants may represent just noise.
<p>
This option is mainly useful for comparison of lexical variants. With phonetic
data, variants that occur only once are very common, and usually don't
represent noise.
</div>

<a name="F"></a>
<h4>Skip files with less than two variants</h4>

<div class="text">
If the option <b>-F</b> is used, all data files that contain only one variant
      are skipped. This not only effects processing speed, but calculated
      differences as well. If there is only one variant form,
      it won't add to the sum of individual differences, but these data are
      counted, and used in the calculation of the average of the differences. This effect is notable unless
      the datafile contains an equal number of strings for each and every
      location.
<p>
Note that this option is effected by the option <b>-f</b>. A datafile may have
	more than one variant, but only one if infrequent variants are removed
	with the option <b>-f</b>. If you use  option <b>-F</b> as well, the
	file will be skipped completely.

</div>

<a name="P"></a>
<h4>Pairwise calculations</h4>

<div class="text">
When the option <b>-P</b> is used, the program processes data in a different
input format, and in a different manner.
<p>
Let's suppose this is all the input data you are working with, listed in a
	schematic way:
<p>
<pre>
        LOC1   LOC2   LOC3
   Wa    a1     a2     a3
   Wb    b1     b2     b3
   Wc    c1            c3
</pre>
<p>
You have data from three locations, LOC1, LOC2, and LOC3, and for three
different words, Wa, Wb, Wc. Item a1 is the variant of word Wa in LOC1, etc.
You can have zero or one variant for each location and word, but not more than
one. In this example, an item c2 is missing
<p>
The program processes this data to give you this:
<p>
<pre>
        LOC1__LOC2   LOC1__LOC3   LOC2_LOC3
   Wa    L(a1,a2)     L(a1,a3)     L(a2,a3)
   Wb    L(b1,b2)     L(b1,b3)     L(b2,b3)
   Wc    NA           L(c1,c2)     NA
</pre>
Where L(a1,a2) = Levenshtein difference between strings a1 and a2, etc.<br>
NA means not available.
<p>
The input file should actually look like this:
<pre>
    : Wa
    [1]- <i>a1</i>
    [2]- <i>a2</i>
    [3]- <i>a3</i>

    : Wb
    [1]- <i>b1</i>
    [2]- <i>b2</i>
    [3]- <i>b3</i>

    : Wc
    [1]- <i>c1</i>
    [3]- <i>c3</i>
</pre>
Empty lines are optional, as well as comment lines.
<p>
In this case, the labels are no location labels but word labels. They are not
actually used, other than as a sign that a new row of data begins. Instead of
labels you can also use numbers (without a leading colon).
These labels or numbers are copied to the output file.
<p>
There are no place labels in the file, nor are they read from a separate label file.
<p>
The numbers in square brackets indicate the column numbers. As you can see
above, you can skip numbers: there is no number 2 for word Wc.
<p>
Instead of starting the actual word variant with a minus, you can use a plus,
followed by a list of numbers, just like in the <a href="#dat">normal datafiles</a>.
<p>
You still need to use the option <b>-n</b> to set the number of locations. In
	the above example it should be 3, because there are three columns.
<p>
This is how the output file could look like:
<pre>
    : Wa
    1 2 0.23
    1 3 0.84
    2 3 0.49

    : Wb
    1 2 0.04
    1 3 0.73
    2 3 0.58

    : Wc
    1 2 NA
    1 3 0.37
    2 3 NA
</pre>
The labels indicate the start of a new row. The pair of numbers in front of
every value indicates the columns numbers that were compared.
<p>
You can have as many columns (locations) as you want. Usually, each column is
compared with every other column. If you have 16 input columns, you
would get 120 output columns. You can limit the output (and the computation
time) if you are interested in only certain column combinations. With
the option <b>-C</b> you can select a column (by number) that should be
tested against all other columns. You can use the option <b>-C</b> more
than once to have more combinations tested. Unselected columns are not
compared with other unselected columns (unless you select no
columns at all).
<p>
For instance, if you select column 2, the output above would look like this
	instead:
<pre>
    : Wa
    1 2 0.23
    2 3 0.49

    : Wb
    1 2 0.04
    2 3 0.58

    : Wc
    1 2 NA
    2 3 NA
</pre>
<p>
The combination 1 3 is missing.
</div>

<a name="wl"></a>
<h4>Weight learning by means of Pointwise Mutual Information</h4>
<div class="text">
Use of the option <b>-S</b> (upper case) initiates the learning of substitution
values. Initial substitution values must be provided in a file
using the option <b>-s</b> (lower case). These values are optimised using
      Pointwise Mutual Information. When the optimisation is completed,
      the updated substitution values are saved to file, and the program
      continues its normal operation using these optimised values.
<p>
Three more options modify the behaviour of the learning process:
<p>

<dl>
<dt><b>-a</b>&nbsp;<em>float</em>
<dd>The learning parameter <em>alpha</em> determines the speed at which
values are updated in each iteration. This can be 1 (full
update, fast, less accurate) or less (partial update, slower, more accurate).<br>Default: 0.3

<dt><b>-v</b>&nbsp;<em>float</em>
<dd>A tiny increment for each
	  alignment count, so there are no zero counts left.<br>Default: 0.001

<dt><b>-z</b>&nbsp;<em>float</em>
<dd>Exponent Z in PMI formula:
	  <blockquote>
<sup>2</sup>log ( <i>p</i>(x, y)<sup>Z</sup> / (<i>p</i>(x) &times; <i>p</i>(y)) )
</blockquote>
Default: 1

</dl>


</div>

</BODY>
</HTML>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:nil
sgml-declaration:"HTML4.01/HTML4.decl"
End:
-->
