<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html40/loose.dtd">
<html>
<head>
  <title>RuG/L04 - Manuals - xstokens</title>
  <link rel="stylesheet" type="text/css" href="manuals.css">
</head>
<body>

<center>
<H1><a href="http://www.let.rug.nl/~kleiweg/L04/"><img src="RuG-L04.gif" alt="RuG/L04" border="0"></a></H1>
<h2>Manuals</h2>
<h3>xstokens</h3>
</center>

<h4>Description</h4>

<div class="text">
tokenise datafiles from X-SAMPA or similar
</div>

<h4>Synopsis</h4>

<div class="text">
<b>xstokens</b>
[<b>-s</b>&nbsp;<em>filename</em>]
<em>xs_table_file</em>
<em>datafile(s)</em>
</div>


<h4>Options</h4>

<div class="text">
<dl>

<dt><b>-s</b>  <em>filename</em>
<dd>save token count to file
</dl>
</div>

<h4>Purpose</h4>

<div class="text">
This program tokenises <a href="leven.html#dat">datafiles</a> that are
processed by the <a href="leven.html">leven</a> program. Strings that represent
a single sound are replaced with a unique code, possibly with additional
codes representing feature characteristics of the sound. The definition for the
      tokenisation is in the <em>xs_table_file</em>.
<p>
The program processes the datafiles given on the command line, creating for
	each file a new file with <b><tt>.tok</tt></b> as an additional
	filename extension. The input files should hold dialect data, in the
	format that is processed by the <b><tt>leven</tt></b> program, but all
	data should be present as strings, preceded with a minus sign. Data
	preceded with a plus sign is not allowed. The output files are again
	in the format that is used by the <b><tt>leven</tt></b> program.
<p>
The datafiles are transformed by matching substrings. When multiple substrings
	match, the longest is used. Each substring is replaced by a token (or
	group of tokens) that is defined in the <em>xs_table_file</em>. In the
	output files, each token is replaced by a unique number.
	The
	idea is that in the input files each sound is represented by a unique
	string, while diacritics such as used in IPA are given as subsequent
	strings following that sound, and these transcriptions can be parsed
	unambiguously by matching substrings from left to right.
<p>
Two different kind of strings are distinguished, representing sortable and
	unsortable substrings. Sortable substrings are sorted as a group. After each
	unsortable substring there can be a group of one or more sortable substrings.
	The unsortable substrings represent basic sounds, or indication of stress
	or linking to the next sound. The sortable substrings represent diacritics,
	that can be given in any order. For instance, the following...
<pre>
      U2 S3 S2 U1 S4 S1
</pre>
... would be sorted as...
<pre>
      U2 S2 S3 U1 S1 S4
</pre>
These means that two input strings that are differing only in the order the
      diacritics are added to the sound will result in identical output strings.
<p>
Empty lines and lines starting with a hash (#) are ignored.
Unsortable substrings are defined with a preceding U:
<pre>
      # vowel, front, close, unrounded
      U  i  .

      # vowel, front, close, rounded
      U  y  .
</pre>
After the substring you put what token it should be translated into. A token is
any sequence of characters not containing white space.
Each time
you use a dot, a new unique token is generated. Any others tokens will be the
      same if they are written the same.
Here, the sound from the input data encoded by the single character <b><tt>i</tt></b> will be encoded as
a single token in the output data, and the <b><tt>y</tt></b> will be encoded as
a different token in the output data.
<p>
Sortable substring are preceded by an S:
<pre>
      S  _h    .
      S  _h\   .
</pre>
<p>
You can translate a sound into a string of tokens, for instance:
<pre>
      # vowel, front, close, unrounded
      U       i       . frontA1 frontB1 closeA1 closeB1 closeC1 unrounded

      # vowel, front, close, rounded
      U       y       . frontA1 frontB1 closeA1 closeB1 closeC1 rounded
</pre>
These two sounds differ in only one phonetic feature. Because they are
      represented by strings of tokens, with only two differences between
      them, (dot vs dot and unrounded vs rounded) the Levenshtein algorithm will find a much smaller difference
      between these two sounds than between sounds that are represented by
      seven different tokens, representing two very dissimilar sounds.
<p>
If you have tokens in the input files that should be excluded from the output,
	put a letter <b><tt>I</tt></b> directly after the first letter. You
	don't need to add tokens for the output:
<pre>
    UI  &lt;
    SI  &gt;
</pre>
This means that the tokens '&lt;' and '&gt;' are ignored.
Note that there is a difference between the two above. The second
      represents a substring that is just ignored. The first, representing an
      unsortable means that not just this substrig should be ignored, but
      also all sortable substrings following, up to the next unsortable.
<p>
Here is an example of an xs_table_file:
<blockquote>
<a href="xstokens-example.txt">xstokens-example.txt</a>
</blockquote>
</div>

<h4>See also</h4>

<div class="text">
The program <a href="features.html">features</a> offers a more accurate method
      to calculate differences based on phonetic features.
</div>

</BODY>
</HTML>
